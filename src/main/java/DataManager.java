/**
 * Model-based Level Set (MLS) Algorithm
 * 
 * COPYRIGHT NOTICE Copyright (c) 2003-2005 Audrey H. Zhuang and Daniel J. Valentino
 * 
 * Please read LICENSE.TXT for the license covering this software
 * 
 * For more information, please contact the authors at: haihongz@seas.ucla.edu
 * dvalentino@mednet.ucla.edu
 */


import ij.IJ;
import ij.ImagePlus;

import java.awt.Color;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Vector;

import loci.formats.FormatException;
import loci.formats.IFormatReader;
import loci.formats.ImageReader;
import loci.formats.MetadataTools;
import loci.formats.gui.BufferedImageReader;
import model.InitialParams;
import model.Metrics;
import model.SegmentResult;
import model.UiOptions;
import utils.LSUtil;

/**
 * Class to read images from the file names provided on the command line as arguments and execute
 * skull-stripping task on them.
 * 
 * @author Audrey H. Zhuang and Daniel J. Valentino
 * @version 2 September 2005
 */
public class DataManager
{


  private List<SkullStripper> skullStrippers = new ArrayList<SkullStripper>();

  private Map<Integer, SegmentResult> segResultMap = new HashMap<Integer, SegmentResult>();

  // /** A vector contains a list of objects of SkullStrippers. */
  // private Vector _skullStrippers = new Vector(1, 1);

  /** Object of AlphaViewport5. */
  private Vector _alphaViewports = new Vector(1, 1);

  /** Maximum iterations. */
  private int MAX_ITER = 255 * 16;

  /** Object of ImageReader. */
  private IFormatReader imgReader;

  private DataVolume dataVolume;

  /** Format type of the given file. */
  private String format = "analyze";

  /** Format names supported by volume constructor. */
  public static final String[] FORMAT_TYPES = {"analyze", "minc", "dicom", "ge", "ucf", "dvazio"};
  /** The function phi. */
  private double[][] _phi = null;

  /** The slice index with which the skull stripping starts with. */
  private int _initialIndex = 0;


  /**
   * The intensity minimum below which lies 2% of the cumulative histogram.
   */
  private double _intens2 = 0;

  /**
   * It is the intensity maxmum below which lies 98% of the cumulative histogram.
   */
  private double _intens98 = 0;
  private double _intens10 = 0;
  private double _intens40 = 0;

  /** Interslice distance (/pixel size). */
  private float INTER_SLICE_DIST = 3;

  /**
   * The orientation of 2D slices resampled from the data volume and stored in the skullStrippers.
   */
  private int resamplingOrient = 0;

  /** Orientation of the 2D image in the loaded file. */
  private int originalOrient = 0;

  /** Bits per pixel. */
  private int _bitsPP = 16;

  /** The way where the head locates: 0-north, 1-east, 2-south, 3-west. */
  private int heading = 0;

  /** Whether to fill holes generated by skull stripping algorithm. */
  private boolean isFillingHolesEnabled = false;

  /** Cut off boundary value of phi. */
  private double BOUNDARY_VALUE = -0.5;

  private float xyDim = 0;

  private double age = 0;

  private double velocity = 0;
  private double threshold = 0;

  private Color contourColor;

  private String filePath;

  private ImagePlus imgPlus;

  private ImagePlus resultImgPlus;

  public DataManager()
  {}

  public DataManager(UiOptions uiOpts, ImagePlus imgPlus)
  {

    this.velocity = uiOpts.getVelocity();
    this.threshold = uiOpts.getThreshold();
    this.isFillingHolesEnabled = uiOpts.isHoleFilling();
    this.heading = uiOpts.getHeading() > 3 ? 0 : uiOpts.getHeading();
    this.contourColor = uiOpts.getContourColor();

    this.imgPlus = imgPlus;

    this.filePath =
        imgPlus.getOriginalFileInfo().directory + imgPlus.getOriginalFileInfo().fileName;
  }

  /**
   * Gets the slice index of the image with which the skull stripping starts with.
   * 
   * @return An integer number.
   */
  public int getInitialIndex()
  {
    return _initialIndex;
  }

  /**
   * Fill the holes in the brain masks.
   */
  // public void fillHoles() {
  // for (int i = 0; i < _skullStrippers.size(); i++) {
  // SkullStripper skullStripper = (SkullStripper) _skullStrippers.elementAt(i);
  // byte[][] outputArray1 = skullStripper.getOutputArray();
  // Filler filler = new Filler(outputArray1);
  // byte[][] outputArray2 = filler.getFilledArray();
  // skullStripper.setOutputArray(outputArray2);
  // }
  // }

  public void fillHoles()
  {
    IJ.log("Fill Holes start.");

    for (SkullStripper skullStripper : skullStrippers)
    {
      skullStripper.setOutputArray(new Filler(skullStripper.getOutputArray()).getFilledArray());
    }

    IJ.log("Fill holes complete.");
  }

  /**
   * Fill the holes in a brain mask stored in a given skullStripper object.
   */
  public void fillHoles(SkullStripper skullStripper)
  {
    byte[][] outputArray1 = skullStripper.getOutputArray();
    Filler filler = new Filler(outputArray1);

    byte[][] outputArray2 = filler.getFilledArray();
    skullStripper.setOutputArray(outputArray2);
  }


  /**
   * Initialize a zero level set circle in a 2D slice resampled from the input file.
   */
  public void initZeroLS()
  {

    ZeroLSInitializer initializer =
        new ZeroLSInitializer(imgReader, skullStrippers, _intens2, _intens98, resamplingOrient,
            xyDim);

    InitialParams initialParams = initializer.getInitParams();
    _initialIndex = initialParams.getInitialIdx();

    // Get an SkullStripper object at the given index
    SkullStripper initSkullStripper = skullStrippers.get(_initialIndex);

    // Set initialization parameters and initialize
    initSkullStripper.setInitialParameters(initialParams.getCenterX(), initialParams.getCenterY(),
        initialParams.getRadius());

    BufferedImage img = initSkullStripper.getInputImage();

    _phi = initSkullStripper.initializePhi();

    // LSUtil.exportAry(LSUtil.binarizeDouble(_phi, 0), "InitialPhi");
    // LSUtil.exportMatFile(_phi, "InitialPhi");
  }

  public void loadMetadata(ImagePlus image)
  {

    try
    {

      imgReader = new ImageReader();

      imgReader.setMetadataStore(MetadataTools.createOMEXMLMetadata());

      imgReader.setId(filePath);

      IJ.log("Width = " + imgReader.getSizeX());
      IJ.log("Height = " + imgReader.getSizeY());

      format = imgReader.getFormat();
      IJ.log("Format = " + imgReader.getFormat());

      // TODO
      originalOrient = 0;
      IJ.log("originalOrient = " + originalOrient);

      // TODO
      resamplingOrient = 0;
      IJ.log("resamplingOrient = " + resamplingOrient);

      _bitsPP = imgReader.getBitsPerPixel();
      IJ.log("Bits per pixel = " + imgReader.getBitsPerPixel());


      IJ.log("Global Meatdata = " + imgReader.getGlobalMetadata().keySet());

      xyDim = Float.valueOf(String.valueOf(imgReader.getGlobalMetadata().get("/xspace step")));

      IJ.log("xyDim = " + xyDim);

      // TODO
      age = 40.0;

      INTER_SLICE_DIST =
          Float.valueOf(String.valueOf(imgReader.getGlobalMetadata().get("/zspace step")));;

      IJ.log("INTER_SLICE_DIST = " + INTER_SLICE_DIST);

    } catch (FormatException e)
    {
      e.printStackTrace();
    } catch (IOException e)
    {
      e.printStackTrace();
    }

  }

  public void createSkullStripper()
  {

    BufferedImageReader bufferedReader = new BufferedImageReader(imgReader);

    BufferedImage[] imgs = null;
    if (resamplingOrient == originalOrient)
    {

      int size = 0;
      size = imgReader.getImageCount();
      imgs = new BufferedImage[size];

      try
      {
        for (int i = 0; i < imgs.length; i++)
        {
          imgs[i] = bufferedReader.openImage(i);
        }

        bufferedReader.close(true);

      } catch (IOException e)
      {
        e.printStackTrace();
      } catch (FormatException e)
      {
        // TODO Auto-generated catch block
        e.printStackTrace();
      }

    } else
    {

      // Start from here TODO
      final DataVolumeResampler dvResampler = new DataVolumeResampler(dataVolume);

      int IMAGE_TYPE = 0;
      if (_bitsPP <= 8)
      {
        IMAGE_TYPE = BufferedImage.TYPE_BYTE_GRAY;
      } else
      {
        IMAGE_TYPE = BufferedImage.TYPE_USHORT_GRAY;
      }

      int size = dataVolume.getDepth(resamplingOrient);


      imgs = new BufferedImage[size];
      for (int i = 0; i < imgs.length; i++)
      {
        imgs[i] = dvResampler.createGrayImage(IMAGE_TYPE, i, resamplingOrient);
      }
    }


    for (int i = 0; i < imgs.length; i++)
    {

      final SkullStripper skullStripper =
          new SkullStripper(imgs[i], velocity, threshold, imgPlus, contourColor);

      skullStripper.setBitsPP(_bitsPP);

      skullStripper.calculateProbingDistance(xyDim, age);

      skullStrippers.add(skullStripper);
    }

    BufferedImage tempImg = skullStrippers.get(64).getInputImage();

    IJ.log("Image Type = " + tempImg.getType());

    IJ.log(tempImg.getRaster().getSample(126, 126, 0) + " "
        + tempImg.getRaster().getSample(127, 126, 0) + " "
        + tempImg.getRaster().getSample(128, 126, 0) + " "
        + tempImg.getRaster().getSample(129, 126, 0));

    IJ.log(tempImg.getRaster().getSample(126, 127, 0) + " "
        + tempImg.getRaster().getSample(127, 127, 0) + " "
        + tempImg.getRaster().getSample(128, 127, 0) + " "
        + tempImg.getRaster().getSample(129, 127, 0));

    IJ.log(tempImg.getRaster().getSample(126, 128, 0) + " "
        + tempImg.getRaster().getSample(127, 128, 0) + " "
        + tempImg.getRaster().getSample(128, 128, 0) + " "
        + tempImg.getRaster().getSample(129, 128, 0));

    IJ.log(tempImg.getRaster().getSample(126, 129, 0) + " "
        + tempImg.getRaster().getSample(127, 129, 0) + " "
        + tempImg.getRaster().getSample(128, 129, 0) + " "
        + tempImg.getRaster().getSample(129, 129, 0));

    IJ.log("Max = " + LSUtil.getMax(tempImg));
    IJ.log("Min = " + LSUtil.getMin(tempImg));

    // Calculate histogram
    calculateBound(skullStrippers);

    // Set intens2, intens10, intens98 to skullStripper
    for (SkullStripper ss : skullStrippers)
    {
      ss.setThresholdIntensities(_intens2, _intens10, _intens40, _intens98);
    }

    try
    {
      bufferedReader.close();
    } catch (IOException e)
    {
      IJ.error("Close bufferReader fail");
    }
  }

  /**
   * Save skull-stripped images.
   * 
   * @param fileName The name of the file to save.
   */
  public void saveBrainOnlyFile(String fileName)
  {
    // FileWriter writer = new FileWriter();
    // BufferedImage[] images = new BufferedImage[skullStrippers.size()];
    //
    // // Get skull-stripped 2D slices from skullStrippers
    // for (int i = 0; i < images.length; i++)
    // {
    // images[i] = skullStrippers.get(i).getOutputImage();
    // }
    //
    // if (originalOrient == resamplingOrient)
    // {
    // writer.saveFile(fileName, images, imgReader);
    // }
    //
    // // If the resamplingOrient is different from the originalOrient, reslice
    // // the data volume according to originalOrient
    // else
    // {
    // MetadataParser mp = new MetadataParser(imgReader);
    // String format = mp.getFormatName();
    // DataVolume dv = new DataVolume(images, resamplingOrient, _bitsPP, format);
    // DataVolumeResampler dvResampler = new DataVolumeResampler(dv);
    // int originalDepth = dv.getDepth(originalOrient);
    // int IMAGE_TYPE = BufferedImage.TYPE_USHORT_GRAY;
    // if (_bitsPP <= 8)
    // IMAGE_TYPE = BufferedImage.TYPE_BYTE_GRAY;
    // BufferedImage[] outputImages = new BufferedImage[originalDepth];
    // for (int i = 0; i < outputImages.length; i++)
    // {
    // outputImages[i] = dvResampler.createGrayImage(IMAGE_TYPE, i, originalOrient);
    // }
    // writer.saveFile(fileName, outputImages, imgReader);
    // }
  }

  /**
   * Save binary images in which 0 represents background and non-zero represents brain tissues. The
   * metadata to save with the skull-stripped results are obtained by revising the metadata of the
   * original image.
   * 
   * @param baseName The name of the file to save, and the extension of the file name, e.g., .mnc,
   *        .hdr, .img etc., will be added by FileWriter class.
   */
  public void saveMaskFile(String fileName)
  {

    // Save the brain masks as Byte images
    // BufferedImage[] images = new BufferedImage[skullStrippers.size()];
    // FileWriter writer = new FileWriter();
    // for (int i = 0; i < images.length; i++)
    // {
    // images[i] = skullStrippers.get(i).getOutputMaskImage();
    // }
    // int intensityOfMask = skullStrippers.get(0).getIntensityOfMask();
    //
    // if (originalOrient == resamplingOrient)
    // {
    // writer.saveMaskFile(fileName, images, intensityOfMask, imgReader);
    // }

    // // If the resamplingOrient is different from the originalOrient, reslice
    // // the data volume according to originalOrient
    // else
    // {
    // MetadataParser mp = new MetadataParser(imgReader);
    // String format = mp.getFormatName();
    // DataVolume dv = new DataVolume(images, resamplingOrient, _bitsPP, format);
    // DataVolumeResampler dvResampler = new DataVolumeResampler(dv);
    // int originalDepth = dv.getDepth(originalOrient);
    // int IMAGE_TYPE = BufferedImage.TYPE_USHORT_GRAY;
    // if (_bitsPP <= 8)
    // IMAGE_TYPE = BufferedImage.TYPE_BYTE_GRAY;
    // BufferedImage[] outputImages = new BufferedImage[originalDepth];
    // for (int i = 0; i < outputImages.length; i++)
    // {
    // outputImages[i] = dvResampler.createGrayImage(IMAGE_TYPE, i, originalOrient);
    // }
    // writer.saveMaskFile(fileName, outputImages, intensityOfMask, imgReader);
    // }
  }

  public void saveMask(String fileName)
  {
    IJ.log("Save masks start: " + fileName + "/" + skullStrippers.size());

    // TODO
    // int sliceNo = 1;
    //
    // for (SkullStripper skullStripper : skullStrippers)
    // {
    // final BufferedImage img = skullStripper.getOutputMaskImage();
    //
    // if (img == null)
    // {
    // IJ.log("Mask" + sliceNo + " is null");
    // }
    //
    // File maskFile = new File(fileName + sliceNo + ".jpg");
    //
    // if (!maskFile.exists())
    // {
    // IJ.error("Create new mask file fail.");
    // }
    //
    // try
    // {
    // boolean isSaved = ImageIO.write(img, "JPEG", maskFile);
    //
    // IJ.log(sliceNo + ":" + isSaved);
    // } catch (IOException e)
    // {
    // IJ.error("Write mask " + sliceNo + "fail");
    // }
    //
    // sliceNo++;
    // }

    IJ.log("Save masks complete.");


  }

  public void evolveVolume()
  {

    int SHRINK_DIST = (int) Math.floor(Math.abs(INTER_SLICE_DIST) + 0.5);
    IJ.log("Shrink distance = " + SHRINK_DIST);

    // The slices, that are around mid-sagittal slices, are estimated to be
    // within SLICE_1 and SLICE_2
    double temp = skullStrippers.size();
    int SLICE_1 = (int) (temp * 0.45);
    int SLICE_2 = (int) (temp * 0.55);

    // Define the length of a small contour
    int SMALL_CIRCLE = 100;

    // // Do skull-stripping on the slice with the "index"
    // SkullStripper skullStripper = skullStrippers.get(_initialIndex);
    // IJ.log("Evolution: " + _initialIndex);
    // _phi = skullStripper.skullStrip(MAX_ITER, _phi);
    //
    // LSUtil.exportMatFile(_phi, "Initialphi");

    // if (isFillingHolesEnabled)
    // {
    // fillHoles(skullStripper);
    // }


    // Keep the _phi for slides before "index"
    double[][] initPhi = LSUtil.copy2DAry(_phi);

    // Temp
    double phiSum = 0;
    for (int i = 0; i < _phi.length; i++)
    {
      for (int j = 0; j < _phi[0].length; j++)
      {
        phiSum += _phi[i][j];
      }
    }

    IJ.log("Initial phi = " + phiSum);

    // Skull-strip slices after "index"
    evolve(_phi, SHRINK_DIST, SLICE_1, SLICE_2, SMALL_CIRCLE, 1);
    IJ.log("Convolution after center finished.");

    // Skull-strip slides before "index"
    evolve(initPhi, SHRINK_DIST, SLICE_1, SLICE_2, SMALL_CIRCLE, -1);
    IJ.log("Convolution before center finished.");


  }

  /**
   * Evolution on half volume
   * 
   * @param _phi
   * @param SHRINK_DIST
   * @param SLICE_1
   * @param SLICE_2
   * @param SMALL_CIRCLE
   * @param direction
   */
  private void evolve(double[][] _phi, int SHRINK_DIST, int SLICE_1, int SLICE_2, int SMALL_CIRCLE,
      int direction)
  {
    int contourLength = 0;
    double[][] phiTemp = null;
    boolean isPhiAcceptable = true;
    double velocity = 0;
    double tempV = 0;
    int sliceIdx = _initialIndex;

    SkullStripper skullStripper;

    while (sliceIdx >= 0 && sliceIdx < skullStrippers.size())
    {

      IJ.log("======= Evolve: " + sliceIdx + " =======");



      skullStripper = skullStrippers.get(sliceIdx);

      SegmentResult segmentResult = new SegmentResult(sliceIdx);


      // The last mask area should be reset at the beginning of the forward evolvement
      if (sliceIdx == _initialIndex)
      {
        skullStripper.clearLastMaskArea();
      }

      // imgPlus.setSlice(sliceIdx);

      phiTemp = LSUtil.copy2DAry(_phi);



      // Shrink the phi zero contour before applying it as an initial contour
      // Using reiniailization method
      _phi = skullStripper.shrinkPhiZero(_phi, SHRINK_DIST);

      final Date tic = new Date();

      _phi = skullStripper.skullStrip(MAX_ITER, _phi, sliceIdx);

      final Date tac = new Date();

      // Export mask image
      // LSUtil.exportAry(skullStripper.getOutputArray(), sliceIdx + "_mask");

      segmentResult.setEvolveTime(tac.getTime() - tic.getTime());

      // Do not check acceptance if the images are around mid-sagittal slices
      // where the CSF change is big and segmentation between slices could be
      // very different
      if ((resamplingOrient == 2 && sliceIdx > SLICE_1 && sliceIdx < SLICE_2)
          || sliceIdx == _initialIndex)
      {

        isPhiAcceptable = true;

      } else
      {
        // Check if the skull-stripped result is acceptable
        isPhiAcceptable = _isPhiAcceptable(_phi, phiTemp);
      }

      IJ.log("1:" + isPhiAcceptable);

      if (!isPhiAcceptable)
      {
        // Increase velocity by 5 times
        velocity = skullStripper.getVelocity();

        skullStripper.setVelocity(velocity * 5);
        skullStripper.setStrippingEnabled(true);
        _phi = skullStripper.shrinkPhiZero(phiTemp, SHRINK_DIST + 10);
        _phi = skullStripper.skullStrip(MAX_ITER, _phi, sliceIdx);

        // Check if the skull-stripped result is acceptable
        isPhiAcceptable = _isPhiAcceptable(_phi, phiTemp);

        IJ.log("2:" + isPhiAcceptable);
        if (!isPhiAcceptable)
        {

          // Increase velocity by 10 times
          skullStripper.setVelocity(velocity * 10);
          skullStripper.setStrippingEnabled(true);
          _phi = skullStripper.shrinkPhiZero(phiTemp, SHRINK_DIST + 5);
          _phi = skullStripper.skullStrip(MAX_ITER, _phi, sliceIdx);

          // Check if the skull-stripped result is acceptable
          isPhiAcceptable = _isPhiAcceptable(_phi, phiTemp);

          IJ.log("3:" + isPhiAcceptable);
        }


        if (!isPhiAcceptable)
        {
          contourLength = LSUtil.calculateContourLength(phiTemp, -0.5d, (byte) 40);

          if (contourLength > SMALL_CIRCLE)
          {

            // Use mask in last slide for current slide

            // MaxIter = 0, no operation => _phi = phiTemp
            _phi = skullStripper.skullStrip(0, phiTemp, sliceIdx);
          } else
          {

            // Shrink the circle to zero
            while (LSUtil.calculateMaskArea(_phi, -0.5d) > 0)
            {
              int shrinkDistTemp = 4;
              _phi = skullStripper.shrinkPhiZero(_phi, shrinkDistTemp);
            }
            _phi = skullStripper.skullStrip(0, _phi, sliceIdx);
          }
        }
      }

      if (isFillingHolesEnabled)
      {
        fillHoles(skullStripper);
      }

      segmentResult.setPhi(_phi);

      segResultMap.put(sliceIdx, segmentResult);

      // LSUtil.exportAry(LSUtil.convertToBinaryAry(_phi, -0.5, (byte) 40), "Mask_" + sliceIdx);

      sliceIdx += direction;
    }

  }


  static
  {
    List formats = Arrays.asList(FORMAT_TYPES);
    if (!formats.contains("analyze"))
      throw new InternalError("Doesn't support analyze file format!");
    if (!formats.contains("minc"))
      throw new InternalError("Doesn't support minc file format!");
    if (!formats.contains("ge"))
      throw new InternalError("Doesn't support ge file format!");
    if (!formats.contains("dicom"))
      throw new InternalError("Doesn't support dicom file format!");
    if (!formats.contains("ucf"))
      throw new InternalError("Doesn't support ucf file format!");
    if (!formats.contains("dvazio"))
      throw new InternalError("Doesn't support dvazio file format!");
  }

  /**
   * Evaluate the skull-stripping algorithm.
   * 
   * @param phi an array containing the family of the level sets.
   * @param labelBImg a buffered image which serves as the golden standard.
   * @return An one element array of double values. The element is the Jaccard coefficient of the
   *         given phi2 compared to the given phi1.
   */
  private double[] _evaluate(double[][] phi1, double[][] phi2)
  {

    // True positive is successfully segmented pixels
    double TP = 0;

    // Pixels in the segmentation result that do not belong to the golden
    // standard: false positive
    double FP = 0;

    // pixels of the golden standard but do not belong to the segmentation
    // results: false negative
    double FN = 0;

    double var1 = 0;
    double var2 = 0;
    for (int x = 0; x < phi1.length; x++)
    {
      for (int y = 0; y < phi1[0].length; y++)
      {
        var1 = phi1[x][y];
        var2 = phi2[x][y];

        // True positive
        if (var1 >= BOUNDARY_VALUE && var2 >= BOUNDARY_VALUE)
          TP += 1;

        // False positive
        if (var1 >= BOUNDARY_VALUE && var2 < BOUNDARY_VALUE)
          FP += 1;

        // False negative
        if (var1 < BOUNDARY_VALUE && var2 >= BOUNDARY_VALUE)
          FN += 1;
      }
    }
    double jaccard = TP / (TP + FP + FN);
    double[] ans = new double[2];
    ans[0] = jaccard;
    return ans;
  }



  /**
   * Get resampling orient that is determined by the orientation giving the shortest depth. For
   * example, if resampling in x direction gives the shortest depth, then the resampling orientation
   * is assigned as axial.
   * 
   * @param metadataParser An parser for parsing image file's metadata.
   * @param dv An dataVolume object storing the data.
   * @return An int value indicating the orientation: 0-axial, 1-coronal, 2-sagittal.
   */
  private int _getResamplingOrient(MetadataParser metadataParser, DataVolume dv)
  {
    int resamplingOrient = 0;


    if (dv.getDepth(0) < dv.getDepth(1) && dv.getDepth(0) < dv.getDepth(2))
    {
      resamplingOrient = 0;
    } else if (dv.getDepth(1) < dv.getDepth(2))
    {
      resamplingOrient = 1;
    } else
      resamplingOrient = 2;

    return resamplingOrient;
  }

  /**
   * Get the interslice distance.
   * 
   * @param metadataParser An parser for parsing image file's metadata.
   * @param resamplingOrient The resampling orientation.
   * @return A float number indicating the inter-slice distance (unit: mm).
   */
  private float _getInterSliceDist(MetadataParser metadataParser, int resamplingOrient)
  {
    float interSliceDist = 1.0f;
    float[] pixDims = metadataParser.getPixDims();

    if (resamplingOrient == 0)
      interSliceDist = pixDims[2];
    else if (resamplingOrient == 1)
      interSliceDist = pixDims[1];
    else
      interSliceDist = pixDims[0];
    return interSliceDist;
  }

  /**
   * Get the 2D resolusions. The pixDims contains 3D resolusions. The 2D will be obtained by
   * comparing the three elements of pixDims array, and by assuming that the pixels are square, that
   * is, the resolusions are the same in x and y directions. So if two elements in pixDims are the
   * same, it is considered the 2D resolusions,
   * 
   * @param metadataParser An parser for parsing image file's metadata.
   * @return A float number indicating the resolution of the pixels (unit: mm).
   */
  private float _getXYDim(MetadataParser metadataParser)
  {
    float xyDim = 1.0f;
    float[] pixDims = metadataParser.getPixDims();

    // Get the 2D resolusions. The pixDims contains 3D resolusions. The 2D
    // will be obtained by comparing the three elements of pixDims array,
    // and by assuming that the pixels are square, that is, the
    // resolusions are the same in x and y directions. So if two elements
    // in pixDims are the same, it is considered the 2D resolusions,
    if (Math.abs(pixDims[0] - pixDims[1]) < (pixDims[0] * 0.1))
      xyDim = pixDims[0];
    else if (Math.abs(pixDims[0] - pixDims[2]) < (pixDims[0] * 0.1))
      xyDim = pixDims[0];
    else if (Math.abs(pixDims[1] - pixDims[2]) < (pixDims[1] * 0.1))
      xyDim = pixDims[1];
    else
      xyDim = 1.0f;
    return xyDim;
  }

  /**
   * Calculate the histogram of an image and initialize the class members of _intens2 and _intens98.
   */
  private void _histogram(Vector skullStrippers)
  {
    // Find the maximum intensity
    int maxI = 0;
    short[][] array = null;
    BufferedImage image = null;
    SkullStripper ac = null;
    for (int z = 0; z < skullStrippers.size(); z++)
    {
      ac = (SkullStripper) skullStrippers.elementAt(z);
      image = ac.getInputImage();
      array = ac.create2DArray(image);
      for (int x = 0; x < array.length; x++)
      {
        for (int y = 0; y < array[0].length; y++)
        {
          if (maxI < array[x][y])
            maxI = array[x][y];
        }
      }
    }

    // Initialize the histogram array
    int[] hist = new int[maxI + 1];

    // Construct histogram array
    int intens;
    for (int z = 0; z < skullStrippers.size(); z++)
    {
      ac = (SkullStripper) skullStrippers.elementAt(z);
      image = ac.getInputImage();
      array = ac.create2DArray(image);
      for (int x = 0; x < array.length; x++)
      {
        for (int y = 0; y < array[0].length; y++)
        {
          intens = array[x][y];
          hist[intens]++;
        }
      }
    }

    // Calculate _intens2
    double sum = 0;
    ac = (SkullStripper) skullStrippers.elementAt(0);
    image = ac.getInputImage();
    int width = image.getWidth();
    int height = image.getHeight();
    double totalSum = width * height * skullStrippers.size();
    for (int k = 0; k < hist.length; k++)
    {
      sum += hist[k];
      if (sum / totalSum > 0.02)
      {
        _intens2 = k;
        k = hist.length;
      }
    }

    // Calculate _intens98
    sum = 0;
    for (int k = 0; k < hist.length; k++)
    {
      sum += hist[k];
      if (sum / totalSum > 0.98)
      {
        _intens98 = k;
        k = hist.length;
      }
    }

    // Calculate _intense10
    _intens10 = Math.floor(((_intens98 - _intens2) * 0.1) + _intens2 + 0.5);

    // Calculate _intens40
    _intens40 = Math.floor(((_intens98 - _intens2) * 0.4) + _intens2 + 0.5);
  }

  private void calculateBound(List<SkullStripper> skullStrippers)
  {
    // Find the maximum intensity
    int maxI = 0;
    int minI = 0;
    short[][] array = null;
    BufferedImage image = null;

    for (SkullStripper skullStripper : skullStrippers)
    {

      image = skullStripper.getInputImage();
      array = skullStripper.create2DArray(image);
      for (int x = 0; x < array.length; x++)
      {
        for (int y = 0; y < array[0].length; y++)
        {
          if (maxI < array[x][y])
            maxI = array[x][y];

          if (minI > array[x][y])
            minI = array[x][y];
        }
      }
    }

    IJ.log("Max intensity = " + maxI);
    IJ.log("Min intensity = " + minI);

    // Initialize the histogram array
    int[] hist = new int[maxI + 1];

    // Construct histogram array
    int intens;
    for (SkullStripper skullStripper : skullStrippers)
    {
      image = skullStripper.getInputImage();
      array = skullStripper.create2DArray(image);
      for (int x = 0; x < array.length; x++)
      {
        for (int y = 0; y < array[0].length; y++)
        {
          intens = array[x][y];
          hist[intens]++;
        }
      }
    }

    // Calculate _intens2
    double sum = 0;
    SkullStripper skullStripper = skullStrippers.get(0);
    image = skullStripper.getInputImage();
    int width = image.getWidth();
    int height = image.getHeight();
    double totalSum = width * height * skullStrippers.size();
    for (int k = 0; k < hist.length; k++)
    {
      sum += hist[k];
      if (sum / totalSum > 0.02)
      {
        _intens2 = k;
        k = hist.length;
      }
    }

    IJ.log("Intensity(2%) = " + _intens2);

    // Calculate _intens98
    sum = 0;
    for (int k = 0; k < hist.length; k++)
    {
      sum += hist[k];
      if (sum / totalSum > 0.98)
      {
        _intens98 = k;
        k = hist.length;
      }
    }

    IJ.log("Intensity(98%) = " + _intens98);

    // Calculate _intense10
    _intens10 = Math.floor(((_intens98 - _intens2) * 0.1) + _intens2 + 0.5);

    // Calculate _intens40
    _intens40 = Math.floor(((_intens98 - _intens2) * 0.4) + _intens2 + 0.5);

    IJ.log("10%/40% = " + _intens10 + "/" + _intens40);
  }

  /**
   * If the segmentation results, represented by phi, is acceptable.
   * 
   * @param phi to check on.
   * @param lastPhi Phi in last (or previous) slide.
   * @return True is phi is acceptable; or false if it is unacceptable.
   */
  private boolean _isPhiAcceptable(double[][] phi, double[][] lastPhi)
  {
    boolean isAcceptable = true;
    double LIMIT_JACCARD = 0.85;

    // =======
    final Metrics metrics =
        new Metrics(LSUtil.convertBoolAry(lastPhi, BOUNDARY_VALUE), LSUtil.convertBoolAry(phi,
            BOUNDARY_VALUE));
    metrics.calculate();

    double jaccard = metrics.getJaccard();

    IJ.log("Jaccard:" + jaccard);

    // double[] temp = _evaluate(lastPhi, phi);
    // double jaccard = temp[0];

    // =======

    int maskArea = LSUtil.calculateMaskArea(phi, -0.5d);
    if (maskArea > 10000 && jaccard < LIMIT_JACCARD)
    {
      isAcceptable = false;

    } else
    {

      int lastMaskArea = 0;
      int contourLength = 0;
      lastMaskArea = LSUtil.calculateMaskArea(lastPhi, -0.5d);
      double difference = maskArea - lastMaskArea;

      double MAX_AREA_DIF = 0;
      contourLength = LSUtil.calculateContourLength(lastPhi, -0.5d, (byte) 40);

      if (contourLength > 0)
      {
        MAX_AREA_DIF = contourLength * (Math.abs(INTER_SLICE_DIST) + 1) * 2;
      } else
      {
        MAX_AREA_DIF = difference;
      }
      // If the difference between lastMaskArea and maskArea is within
      // 15% of lastMaskArea, then phi is acceptable
      if (difference > MAX_AREA_DIF)
      {
        isAcceptable = false;
      }

    }

    return isAcceptable;
  }

  public List<SegmentResult> evaluateResult()
  {
    final List<SegmentResult> orderedSegResult = new ArrayList<SegmentResult>();

    for (int i = 0; i < imgPlus.getStackSize(); i++)
    {
      final SegmentResult segResult = segResultMap.get(i);

      final Metrics metrics =
          new Metrics(LSUtil.convertBoolAry(segResult.getPhi(), BOUNDARY_VALUE),
              LSUtil.convertBoolAry(segResult.getPhi(), BOUNDARY_VALUE));
      metrics.calculate();

      segResult.setMetrics(metrics);

      orderedSegResult.add(segResult);

    }

    return orderedSegResult;
  }


  /**
   * Close reader
   */
  public void closeReader()
  {
    try
    {
      imgReader.close();
    } catch (IOException e)
    {
      IJ.error("Close reader fails");
    }
  }
}
